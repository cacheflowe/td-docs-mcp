"""
TouchDesigner Documentation Cleaner

Cleans up markdown files generated by crawl4ai to improve readability.
"""

import argparse
import re
import shutil
import sys
from pathlib import Path


def clean_python_blockquotes(content: str) -> str:
    """
    Clean up blockquote formatting in Python documentation.

    The Python docs have excessive blockquotes that interfere with formatting.
    This function:
    - Removes `> ` prefix from description lines
    - Preserves code blocks but removes blockquote prefix
    - Ensures proper spacing around any remaining blockquotes
    - Adds blank lines before member/method definitions
    """
    lines = content.split('\n')
    cleaned = []
    in_code_block = False

    # Pattern for member definitions: `name` → `type` : or `name` → `type` **(Read Only)** :
    member_pattern = re.compile(r'^`[^`]+`\s*→\s*`[^`]+`.*:\s*$')

    i = 0
    while i < len(lines):
        line = lines[i]

        # Track code blocks
        if line.strip().startswith('```') or line.strip().startswith('> ```'):
            # Starting or ending a code block
            if line.strip().startswith('> ```'):
                # Remove blockquote from code fence
                line = line.replace('> ```', '```', 1)

            if not in_code_block:
                in_code_block = True
                # Ensure blank line before code block if previous line isn't blank
                if cleaned and cleaned[-1].strip() != '':
                    cleaned.append('')
            else:
                in_code_block = False

            cleaned.append(line)
            i += 1
            continue

        # Inside code block - remove blockquote prefix if present
        if in_code_block:
            if line.startswith('> '):
                line = line[2:]
            elif line.startswith('>'):
                line = line[1:]
            cleaned.append(line)
            i += 1
            continue

        # Outside code block - handle blockquotes
        if line.startswith('> '):
            # Check if this is a "real" blockquote (intentional quote) or just formatting artifact
            # In Python docs, most > lines are just descriptions, not actual quotes
            # Remove the blockquote prefix
            line = line[2:]
        elif line.strip() == '>':
            # Empty blockquote line - skip it
            i += 1
            continue

        # Add blank line before member definitions (but not if already blank or after header)
        if member_pattern.match(line):
            if cleaned and cleaned[-1].strip() != '' and not cleaned[-1].startswith('#'):
                cleaned.append('')

        cleaned.append(line)
        i += 1

    return '\n'.join(cleaned)


def remove_operator_family_footer(content: str) -> str:
    """Remove the operator family link list footer from the end of docs.

    TD wiki pages end with a section containing the operator family name
    (e.g. "CHOPs"), a "---" separator, a long line of links to every
    operator in that family, and several glossary definition lines. This
    is redundant navigation chrome that doesn't belong in the markdown.
    """
    lines = content.split('\n')
    # Known operator family names that appear as footer headers
    family_names = {'CHOPs', 'TOPs', 'SOPs', 'DATs', 'MATs', 'COMPs', 'POPs'}

    # Search from the end backwards for efficiency — the footer is always
    # at the tail of the file.
    for i in range(len(lines) - 1, 0, -1):
        stripped = lines[i].strip()
        if stripped in family_names and i + 1 < len(lines) and lines[i + 1].strip() == '---':
            # Truncate everything from this line onward
            result = '\n'.join(lines[:i]).rstrip()
            return result + '\n'

    return content


def remove_page_footer(content: str) -> str:
    """Remove trailing boilerplate after the last meaningful content.

    Class pages end with `__setstate__()` and a one-line description, followed
    by glossary definitions and other boilerplate.  Keep the `__setstate__`
    line and its description, discard everything after.  Falls back to
    truncating at a "TouchDesigner Build" line if present.
    """
    lines = content.split('\n')

    # Look for __setstate__ — keep it + next non-blank line, discard the rest
    for i, line in enumerate(lines):
        if '__setstate__' in line:
            # Find the description line (next non-blank line after __setstate__)
            desc_idx = None
            for j in range(i + 1, len(lines)):
                if lines[j].strip():
                    desc_idx = j
                    break
            if desc_idx is not None:
                result = '\n'.join(lines[:desc_idx + 1]).rstrip()
            else:
                result = '\n'.join(lines[:i + 1]).rstrip()
            return result + '\n'

    # Fallback: truncate at "TouchDesigner Build" line
    for i, line in enumerate(lines):
        if 'TouchDesigner Build' in line:
            result = '\n'.join(lines[:i]).rstrip()
            return result + '\n'

    return content


def format_parameter_bullets(content: str) -> str:
    """Convert parameter lines in Parameters sections to bullet points.

    In TD docs, parameter lines follow the pattern:
        ParamName `identifier` - description
    These are plain text lines that collapse into a single paragraph in
    markdown. This function prefixes them with '- ' to render as a proper
    list. It also removes blank lines between sub-bullet items (indented
    '* ' lines) so nested lists render correctly.
    """
    lines = content.split('\n')
    result = []
    in_params_section = False

    # Matches: "ParamName `identifier` - description"
    # Starts with a letter, has a backtick-wrapped identifier, then " - "
    param_pattern = re.compile(r'^[A-Za-z][^`]*`\w+`\s*-')
    # Matches sub-bullet items: leading whitespace then "* "
    sub_bullet_pattern = re.compile(r'^\s+\*\s')

    for i, line in enumerate(lines):
        stripped = line.strip()

        # Detect Parameters section headers
        if re.match(r'^## Parameters', stripped):
            in_params_section = True
            result.append(line)
            continue

        # Detect other section headers (exit params section)
        if stripped.startswith('## ') or stripped.startswith('# '):
            in_params_section = False
            result.append(line)
            continue

        if in_params_section:
            # Convert top-level parameter lines to bullet points
            if param_pattern.match(stripped):
                result.append(f'- {stripped}')
                continue

            # Remove blank lines that precede a sub-bullet or another param
            # so nested lists stay contiguous
            if stripped == '' and i + 1 < len(lines):
                next_line = lines[i + 1]
                next_stripped = next_line.strip()
                if sub_bullet_pattern.match(next_line) or param_pattern.match(next_stripped):
                    continue

        result.append(line)

    return '\n'.join(result)


def convert_self_anchor_links(content: str) -> str:
    """Convert absolute anchor links to relative when they point to the same page.

    TOC entries and self-references use absolute URLs like:
        [1 Members](https://docs.derivative.ca/BloomTOP_Class#Members)
    This converts them to relative anchors so they work in local markdown:
        [1 Members](#Members)

    Only links whose URL page name matches the file's frontmatter title are
    converted; cross-page anchor links are left unchanged.
    """
    # Extract title from YAML frontmatter
    if not content.startswith('---'):
        return content
    parts = content.split('---', 2)
    if len(parts) < 3:
        return content
    title = ''
    for line in parts[1].strip().split('\n'):
        if line.startswith('title:'):
            title = line[len('title:'):].strip()
            break
    if not title:
        return content

    # Replace [text](https://docs.derivative.ca/Title#fragment "optional") -> [text](#fragment)
    pattern = (
        r'\[([^\]]+)\]\(https://docs\.derivative\.ca/'
        + re.escape(title)
        + r'#([^)\s"]+)(?:\s+"[^"]*")?\)'
    )
    return re.sub(pattern, r'[\1](#\2)', content)


def ensure_blockquote_spacing(content: str) -> str:
    """Ensure blank lines before and after blockquote lines.

    Lines starting with > should have blank lines around them for proper
    markdown rendering.  Consecutive blockquote lines are treated as a single
    block (spacing is only added before the first and after the last).
    Code-fenced regions are left untouched.
    """
    lines = content.split('\n')
    result = []
    in_code_block = False
    frontmatter_count = 0

    for line in lines:
        stripped = line.strip()

        # Track frontmatter — pass through unchanged
        if stripped == '---':
            frontmatter_count += 1
        if frontmatter_count < 2:
            result.append(line)
            continue

        # Track code blocks — pass through unchanged
        if stripped.startswith('```'):
            in_code_block = not in_code_block
            result.append(line)
            continue
        if in_code_block:
            result.append(line)
            continue

        if stripped.startswith('>'):
            # Blank line before, unless previous line is blank or also a blockquote
            if result and result[-1].strip() != '' and not result[-1].strip().startswith('>'):
                result.append('')
            result.append(line)
        else:
            # Blank line after a blockquote block, unless current line is blank
            if result and result[-1].strip().startswith('>') and stripped != '':
                result.append('')
            result.append(line)

    return '\n'.join(result)


def clean_td_markdown(content: str, is_python_doc: bool = False) -> str:
    """Clean TouchDesigner documentation markdown."""
    lines = content.split('\n')
    cleaned = []
    in_frontmatter = False
    frontmatter_count = 0
    skip_toc = False

    for line in lines:
        # Track frontmatter
        if line.strip() == '---':
            frontmatter_count += 1
            in_frontmatter = frontmatter_count == 1
            cleaned.append(line)
            continue

        # Preserve frontmatter as-is
        if frontmatter_count < 2:
            cleaned.append(line)
            continue

        # Remove 'From Derivative' line
        if line.strip() == 'From Derivative':
            continue

        # Remove wikieditor metadata lines
        if 'wikieditor' in line.lower():
            continue

        # Remove 'Jump to navigation/search' links
        if 'Jump to navigation' in line or 'Jump to search' in line:
            continue

        # Remove edit links [[edit](...)]
        line = re.sub(r'\s*\[\[edit\]\([^)]+\)\]', '', line)

        # Remove standalone [edit](...) links
        line = re.sub(r'\s*\[edit\]\(https://docs\.derivative\.ca/index\.php[^)]+\)', '', line)

        # Remove empty ## headers (MediaWiki artifact)
        if line.strip() == '##':
            continue

        # Strip >> (double blockquote) prefix — formatting artifact
        if line.startswith('>>'):
            line = re.sub(r'^>>\s?', '', line)

        # Skip Contents/TOC section
        if line.strip() == '## Contents':
            skip_toc = True
            continue
        if skip_toc:
            # TOC lines are indented lists with [number
            if re.match(r'\s*\*\s*\[\d+', line) or line.strip() == '':
                if line.strip() == '':
                    skip_toc = False  # Empty line ends TOC
                continue
            else:
                skip_toc = False

        # Clean up Python icon + class links: [![PythonIcon...](...)[Class](...) -> [Class](...)
        line = re.sub(r'\[!\[PythonIcon\.png\]\([^)]+\)\]\([^)]+\)', '', line)

        # Fix section headers that lost their ## prefix
        # Common patterns: "Summary", "Parameters - X Page", "Operator Inputs", etc.
        header_patterns = [
            r'^(Summary)$',
            r'^(Parameters\s*-\s*.+Page)$',
            r'^(Operator Inputs)$',
            r'^(Operator Outputs)$',
            r'^(Info CHOP Channels)$',
            r'^(Common .+ Info Channels)$',
            r'^(Methods)$',
            r'^(Members)$',
            r'^(Special Members)$',
            r'^(See Also)$',
            r'^(Examples?)$',
            r'^(Notes?)$',
            r'^(Usage)$',
        ]

        stripped = line.strip()
        for pattern in header_patterns:
            if re.match(pattern, stripped, re.IGNORECASE):
                line = f'## {stripped}'
                break

        cleaned.append(line)

    # Join and clean up
    result = '\n'.join(cleaned)

    # Apply Python-specific cleaning if this is a Python doc
    if is_python_doc:
        result = clean_python_blockquotes(result)

    # Convert same-page absolute anchor links to relative
    result = convert_self_anchor_links(result)

    # Ensure blank lines around blockquote lines
    result = ensure_blockquote_spacing(result)

    # Remove operator family link list footer (CHOPs, TOPs, etc.)
    result = remove_operator_family_footer(result)

    # Remove trailing boilerplate (glossary defs, build info, etc.)
    result = remove_page_footer(result)

    # Format parameter sections with proper bullet points
    result = format_parameter_bullets(result)

    # Contract multiple empty lines to max 2
    result = re.sub(r'\n{3,}', '\n\n', result)

    # Remove trailing whitespace from lines
    result = '\n'.join(line.rstrip() for line in result.split('\n'))

    return result.strip() + '\n'


def clean_file(file_path: Path, dry_run: bool = False) -> bool:
    """Clean a single markdown file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            original = f.read()

        # Detect if this is a Python documentation file
        is_python_doc = 'Python' in str(file_path) or '_Class.md' in str(file_path)

        cleaned = clean_td_markdown(original, is_python_doc=is_python_doc)

        if cleaned != original:
            if not dry_run:
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(cleaned)
            return True
        return False
    except Exception as e:
        print(f"  Error processing {file_path}: {e}", file=sys.stderr)
        return False


def relocate_general_files(docs_dir: Path, dry_run: bool = False) -> int:
    """Move general/meta wiki pages into a shared General directory.

    Pages like TouchDesigner_Glossary.md and Tutorials.md appear in
    multiple category directories. This consolidates them into a single
    General/ directory and removes duplicates.
    """
    # Kept in sync with GENERAL_PAGE_FILENAMES in crawler.py.
    # Duplicated here to avoid importing crawler (which pulls in crawl4ai).
    general_filenames = {
        "TouchDesigner_Glossary.md",
        "TouchDesigner_Python_Classes.md",
        "Tutorials.md",
        "Derivative_About.md",
        "Derivative_General_disclaimer.md",
        "Derivative_Privacy_policy.md",
        "Frequently_Asked_Questions.md",
        "Interoperability.md",
        "Learn_TouchDesigner.md",
        "Main_Page.md",
        "Release_Notes.md",
        "Python.md",
        "Operator.md",
    }

    general_dir = docs_dir / "General"
    moved = 0

    for md_file in sorted(docs_dir.rglob("*.md")):
        if md_file.name not in general_filenames:
            continue
        # Skip files already in General/
        if md_file.parent == general_dir:
            continue

        target = general_dir / md_file.name
        action = "Would move" if dry_run else "Moved"

        if target.exists():
            # Duplicate — just delete it
            if not dry_run:
                md_file.unlink()
            print(f"  Removed duplicate: {md_file.relative_to(docs_dir)}")
        else:
            if not dry_run:
                general_dir.mkdir(parents=True, exist_ok=True)
                shutil.move(str(md_file), str(target))
            print(f"  {action}: {md_file.relative_to(docs_dir)} -> General/{md_file.name}")
            moved += 1

    return moved


def clean_directory(docs_dir: Path, dry_run: bool = False) -> tuple[int, int]:
    """Clean all markdown files in the documentation directory."""
    # First, relocate general pages to the General directory
    relocated = relocate_general_files(docs_dir, dry_run)
    if relocated:
        print()

    cleaned_count = 0
    total_count = 0

    for md_file in docs_dir.rglob('*.md'):
        total_count += 1
        if clean_file(md_file, dry_run):
            cleaned_count += 1
            action = "Would clean" if dry_run else "Cleaned"
            print(f"  {action}: {md_file.relative_to(docs_dir)}")

    return cleaned_count, total_count


def main():
    """CLI entry point."""
    parser = argparse.ArgumentParser(
        description="Clean TouchDesigner documentation markdown files"
    )
    parser.add_argument(
        "-d", "--docs-dir",
        type=Path,
        default=Path("td_docs"),
        help="Documentation directory (default: td_docs)"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Show what would be cleaned without making changes"
    )
    parser.add_argument(
        "-f", "--file",
        type=Path,
        help="Clean a single file instead of the whole directory"
    )

    args = parser.parse_args()

    print("TouchDesigner Documentation Cleaner")
    print("=" * 40)

    if args.file:
        if clean_file(args.file, args.dry_run):
            action = "Would clean" if args.dry_run else "Cleaned"
            print(f"{action}: {args.file}")
        else:
            print(f"No changes needed: {args.file}")
    else:
        if not args.docs_dir.exists():
            print(f"Error: Directory not found: {args.docs_dir}", file=sys.stderr)
            sys.exit(1)

        print(f"Directory: {args.docs_dir}")
        if args.dry_run:
            print("Mode: DRY RUN (no changes will be made)")
        print()

        cleaned, total = clean_directory(args.docs_dir, args.dry_run)

        print()
        print("=" * 40)
        action = "Would clean" if args.dry_run else "Cleaned"
        print(f"{action} {cleaned} of {total} files")


if __name__ == "__main__":
    main()
